const chalk = require('chalk');

class SuggestionFormatter {
  constructor(options = {}) {
    this.options = {
      format: 'github', // 'github', 'cli', 'json'
      includeMetadata: true,
      groupBySeverity: true,
      ...options
    };
  }

  format(analysis, context = {}) {
    if (!analysis.needsUpdate) {
      return this.formatNoUpdatesNeeded(context);
    }

    switch (this.options.format) {
      case 'github':
        return this.formatForGitHub(analysis, context);
      case 'cli':
        return this.formatForCLI(analysis, context);
      case 'json':
        return this.formatAsJSON(analysis, context);
      default:
        throw new Error(`Unknown format: ${this.options.format}`);
    }
  }

  formatForGitHub(analysis, context) {
    const { suggestions } = analysis;
    const { repoName = '', prNumber = '', author = '' } = context;

    let output = `<!-- README-BOT -->\n`;
    output += `## 📚 README Update Suggestions\n\n`;
    
    if (author) {
      output += `Hey @${author}! 👋 I've analyzed your changes and found some items that might need README updates.\n\n`;
    }

    if (this.options.groupBySeverity) {
      const grouped = this.groupBySeverity(suggestions);
      
      if (grouped.high.length > 0) {
        output += `### 🔴 High Priority\n`;
        output += this.formatSuggestionGroup(grouped.high, 'github');
        output += `\n`;
      }

      if (grouped.medium.length > 0) {
        output += `### 🟡 Medium Priority\n`;
        output += this.formatSuggestionGroup(grouped.medium, 'github');
        output += `\n`;
      }

      if (grouped.low.length > 0) {
        output += `### 🟢 Low Priority\n`;
        output += this.formatSuggestionGroup(grouped.low, 'github');
        output += `\n`;
      }
    } else {
      output += this.formatSuggestionGroup(suggestions, 'github');
    }

    output += `\n---\n`;
    output += `💡 **Tip:** You can run \`npx readme-bot\` locally to apply these suggestions automatically.\n\n`;
    output += `<sub>🤖 This comment was generated by README-Bot powered by Claude AI</sub>`;

    return output;
  }

  formatForCLI(analysis, context) {
    const { suggestions } = analysis;

    if (!analysis.needsUpdate) {
      return chalk.green('✅ Your README looks up to date!');
    }

    let output = chalk.blue.bold('\n📚 README Update Suggestions\n');
    output += chalk.gray('─'.repeat(50)) + '\n';

    if (this.options.groupBySeverity) {
      const grouped = this.groupBySeverity(suggestions);
      
      if (grouped.high.length > 0) {
        output += chalk.red.bold('\n🔴 High Priority:\n');
        output += this.formatSuggestionGroup(grouped.high, 'cli');
      }

      if (grouped.medium.length > 0) {
        output += chalk.yellow.bold('\n🟡 Medium Priority:\n');
        output += this.formatSuggestionGroup(grouped.medium, 'cli');
      }

      if (grouped.low.length > 0) {
        output += chalk.green.bold('\n🟢 Low Priority:\n');
        output += this.formatSuggestionGroup(grouped.low, 'cli');
      }
    } else {
      output += this.formatSuggestionGroup(suggestions, 'cli');
    }

    output += chalk.gray('\n' + '─'.repeat(50));
    output += chalk.blue(`\n💡 Found ${suggestions.length} suggestion${suggestions.length !== 1 ? 's' : ''} for your README\n`);

    return output;
  }

  formatAsJSON(analysis, context) {
    return JSON.stringify({
      ...analysis,
      metadata: {
        timestamp: new Date().toISOString(),
        context,
        formatterVersion: '1.0.0'
      }
    }, null, 2);
  }

  formatSuggestionGroup(suggestions, format) {
    return suggestions.map((suggestion, index) => {
      return this.formatSingleSuggestion(suggestion, format, index + 1);
    }).join('\n');
  }

  formatSingleSuggestion(suggestion, format, index) {
    const { type, section, description, priority, content } = suggestion;

    switch (format) {
      case 'github':
        return this.formatSuggestionForGitHub(suggestion, index);
      case 'cli':
        return this.formatSuggestionForCLI(suggestion, index);
      default:
        return JSON.stringify(suggestion, null, 2);
    }
  }

  formatSuggestionForGitHub(suggestion, index) {
    const { type, section, description, content } = suggestion;
    const emoji = this.getEmojiForType(type);
    
    let output = `#### ${emoji} ${this.capitalizeFirst(type)} Update\n`;
    output += `**Section:** ${section}\n`;
    output += `**Description:** ${description}\n`;
    
    if (content) {
      output += `\n<details>\n<summary>Suggested content</summary>\n\n`;
      output += `\`\`\`markdown\n${content}\n\`\`\`\n\n</details>\n`;
    }

    return output;
  }

  formatSuggestionForCLI(suggestion, index) {
    const { type, section, description, content } = suggestion;
    const emoji = this.getEmojiForType(type);
    
    let output = chalk.cyan(`\n${index}. ${emoji} ${this.capitalizeFirst(type)} Update\n`);
    output += chalk.white(`   Section: ${chalk.bold(section)}\n`);
    output += chalk.white(`   ${description}\n`);
    
    if (content) {
      const lines = content.split('\n');
      const preview = lines.slice(0, 3).join('\n');
      const hasMore = lines.length > 3;
      
      output += chalk.gray(`   Suggested content:\n`);
      output += chalk.gray(`   ${preview.replace(/\n/g, '\n   ')}`);
      if (hasMore) {
        output += chalk.gray(`\n   ... (${lines.length - 3} more lines)`);
      }
      output += '\n';
    }

    return output;
  }

  formatNoUpdatesNeeded(context) {
    switch (this.options.format) {
      case 'github':
        return `<!-- README-BOT -->\n## ✅ README Looks Good!\n\nI've analyzed your changes and your README appears to be up to date. No updates needed! 🎉\n\n<sub>🤖 This comment was generated by README-Bot powered by Claude AI</sub>`;
      case 'cli':
        return chalk.green('\n✅ Your README looks up to date! No changes needed.\n');
      case 'json':
        return JSON.stringify({ needsUpdate: false, suggestions: [], timestamp: new Date().toISOString() }, null, 2);
    }
  }

  groupBySeverity(suggestions) {
    return {
      high: suggestions.filter(s => s.priority === 'high'),
      medium: suggestions.filter(s => s.priority === 'medium'),
      low: suggestions.filter(s => s.priority === 'low')
    };
  }

  getEmojiForType(type) {
    const emojiMap = {
      env: '🔐',
      dependency: '📦',
      feature: '✨',
      setup: '⚙️',
      api: '🔌',
      architecture: '🏗️',
      config: '⚙️',
      documentation: '📖'
    };

    return emojiMap[type] || '📝';
  }

  capitalizeFirst(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }

  static create(format, options = {}) {
    return new SuggestionFormatter({ format, ...options });
  }
}

module.exports = SuggestionFormatter;